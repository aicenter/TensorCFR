#!/usr/bin/env python3

from src.algorithms.tensorcfr_best_response.TensorCFR_BestResponse import TensorCFR_BestResponse
from src.commons.constants import PLAYER1, PLAYER2

TOTAL_STEPS = 10


class ExploitabilityByTensorCFR:
	def __init__(self, domain, trunk_strategies):
		self._domain = domain
		self._trunk_strategies = trunk_strategies
		self.compute_best_response_values()
		self.compute_exploitabilities()

	def compute_best_response_values(self):
		self.tensorcfr_br_player1 = TensorCFR_BestResponse(
			best_responder=PLAYER1,
			trunk_strategies=self._trunk_strategies,
			domain=self._domain,
			trunk_depth=4  # TODO to constructor
		)
		self.tensorcfr_br_player2 = TensorCFR_BestResponse(
			best_responder=PLAYER2,
			trunk_strategies=self._trunk_strategies,
			domain=self._domain,
			trunk_depth=4
		)

		self.final_brvalue_1 = self.tensorcfr_br_player1.get_best_response_value_via_cfr(
			total_steps=TOTAL_STEPS,  # TODO to constructor
			delay=1,  # TODO to constructor
		)
		self.final_brvalue_2 = self.tensorcfr_br_player2.get_best_response_value_via_cfr(
			total_steps=TOTAL_STEPS,
			delay=1,
		)

		self.brvalues1 = self.tensorcfr_br_player1.best_response_values
		self.brvalues2 = self.tensorcfr_br_player2.best_response_values

	def compute_exploitabilities(self):
		self.exploitabilities = [
			(u1 + u2) / 2
			for (u1, u2)
			in zip(self.brvalues1, self.brvalues2)
		]
		self.final_exploitability = (self.final_brvalue_1 + self.final_brvalue_2) / 2
